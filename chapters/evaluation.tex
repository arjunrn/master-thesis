\chapter{Evaluation}

The peak write throughput performance of the original ZooKeeper and ParKazoo are compared.

\section{Test Setup}
The tests are performed on a Ganglia~\cite{sacerdoti2003wide} cluster. The Fabric library is used to for performing the tests. Fabric is a library for application deployment~\cite{spotswood2003systems} and system administration. The first step is to start the required the server set, either ZooKeeper or ParKazoo and configure them. Then the machines which make the requests are are configured next. For convenience's sake let us refer to them as \textit{Requesters}. The Requesters run a python script which forks and creates P number of slave processes. Each slave process in turn spawns T number of threads. Each threads get its own client object which it can use to make requests to the main ensemble. A ParKazoo/Kazoo barrier is used to wait for all the processes to initialize and spawn their threads. Once all the processes reach this barrier and cross the begin to execute a loop. The loops contains a \textit{create()} to create a node in the ParKazoo/ZooKeeper tree structure. Upon successful creation of the node the thread records the the current time and also the time it took to execute the operation. After that it removes the same node using the \textit{delete()} operations. After this it records the timestamps and execution time just like for the create operation. Conceptually the create and delete operations are equivalent because they both require consensus between a majority of the servers. The created nodes are not retained on the server because the performance of the cluster gradually diminishes as the amount of data it contains increases. After a prefixed amount of time has elapsed the value a node is set on the cluster. All the \textit{Requesters} have a \textit{DataWatch} on this node. When the value is set it indicates to the the \textit{Requesters} to stop executing the requests loop. After this every processes collects the timestamps-duration pair lists from every thread and writes it to disk. 

\subsection{Testing Process}
The objective of the testing process is to find the peak throughput and the latencies. The setup contains an ensemble of servers: either a ZooKeeper cluster with 3 servers or a ParKazoo ensemble consisting of 3 clusters with 3 servers. While it would be expected that a 9-Server ParKazoo ensemble should be compared against a 9-Server ZooKeeper cluster, it is more fair to compare it against a 3-Server ZooKeeper cluster. Both the 3-Server ZooKeeper cluster and 9-Server cluster can tolerate a single server failure. Also since the performance of a cluster is inversely proportional to the size of cluster, the fastest ZooKeeper configuration is a 3-Server configuration. This is an advantage which a 9-Server ParKazoo ensemble inherently possesses.

\begin{enumerate}
  \item In the beginning with a single client node running only a single processing gradually increment the number of threads making requests until the maximum throughput is obtained. This gives T which is the maximum number of threads which can be run before the performance degrades due to context switching and other threading limitations.
  \item Then with T number of threads increase the number of processes until maximum throughput is achieved. This gives P which is number of processes.
  \item For T number of threads and P number of processes increase the number of clients until maximum throughput is achieved.
\end{enumerate}


\input{charts/parkazoo_1_1_1_throughput}

\input{charts/parkazoo_1_1_1_requests}

\input{charts/throughput_65_10_15}

\input{charts/requests_65_10_15}

\input{tables/single_process}

Multiple nodes make requests to the cluster or the ensemble. Each node has multiple processes and each process has in turn multiple threads. Each thread has its own Kazoo or ParKazoo client object to make requests to the servers.
Kazoo/ParKazoo provides a recipe for barrier which is used by the clients to start making requests. All the nodes start making request when they clear the barrier. Every request is recorded with a timestamp and the time it took to complete the request. All these timestamped requests from each thread are collected and finally they are written to the disk. At the end of the run all the files containing the requests timestamp and duration are collected. They are then aggregated. They are bucketed by the to the second in which they were executed. This gives the number of requests from all the test nodes that occurred in a second. The average request rate and their latency is recorded. 

\section{Conclusion}
As we can see from the throughput rates when the number of clients is smaller the throughput of the ParKazoo is almost 20\%-30\% higher than the equivalent ZooKeeper setup. However when the number of ParKazoo clients on a single node increases the throughput rate fails to grow and at a certain point drops below the throughput rate of the the equivalent ZooKeeper test node. But the total throughput of ZooKeeper plateaus out at around 6300 requests/seconds. However the request throughput of ParKazoo can reach almost 8000 requests/second.

The reason for the deteriorated performance of ParKazoo when more processes and threads are present is probably due to the higher number of open connections. This issue may need to be investigated further. 
